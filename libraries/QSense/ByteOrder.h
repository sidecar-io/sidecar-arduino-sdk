/*
 Copyright (c) 2004-2006, Applied Informatics Software Engineering GmbH.
 and Contributors.

 Permission is hereby granted, free of charge, to any person or organization
 obtaining a copy of the software and accompanying documentation covered by
 this license (the "Software") to use, reproduce, display, distribute,
 execute, and transmit the Software, and to prepare derivative works of the
 Software, and to permit third-parties to whom the Software is furnished to
 do so, all subject to the following:

 The copyright notices in the Software and this entire statement, including
 the above license grant, this restriction and the following disclaimer,
 must be included in all copies of the Software, in whole or in part, and
 all derivative works of the Software, unless such copies or derivative
 works are solely in the form of machine-executable object code generated by
 a source language processor.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.
*/


#ifndef QSENSE_BYTEORDER_H
#define QSENSE_BYTEORDER_H

#if defined( ARDUINO )
#include "QSense.h"
#else
#include <QSense.h>
#endif

namespace qsense
{
/**
 * @brief This class contains a number of static methods
 * to convert between big-endian and little-endian
 * integers of various sizes.
 */
class ByteOrder
{
public:
  static int16_t flipBytes(int16_t value);
  static uint16_t flipBytes(uint16_t value);
  static int32_t flipBytes(int32_t value);
  static uint32_t flipBytes(uint32_t value);
  static int64_t flipBytes(int64_t value);
  static uint64_t flipBytes(uint64_t value);

  static int16_t toBigEndian(int16_t value);
  static uint16_t toBigEndian (uint16_t value);
  static int32_t toBigEndian(int32_t value);
  static uint32_t toBigEndian (uint32_t value);
  static int64_t toBigEndian(int64_t value);
  static uint64_t toBigEndian (uint64_t value);

  static int16_t fromBigEndian(int16_t value);
  static uint16_t fromBigEndian (uint16_t value);
  static int32_t fromBigEndian(int32_t value);
  static uint32_t fromBigEndian (uint32_t value);
  static int64_t fromBigEndian(int64_t value);
  static uint64_t fromBigEndian (uint64_t value);

  static int16_t toLittleEndian(int16_t value);
  static uint16_t toLittleEndian (uint16_t value);
  static int32_t toLittleEndian(int32_t value);
  static uint32_t toLittleEndian (uint32_t value);
  static int64_t toLittleEndian(int64_t value);
  static uint64_t toLittleEndian (uint64_t value);

  static int16_t fromLittleEndian(int16_t value);
  static uint16_t fromLittleEndian (uint16_t value);
  static int32_t fromLittleEndian(int32_t value);
  static uint32_t fromLittleEndian (uint32_t value);
  static int64_t fromLittleEndian(int64_t value);
  static uint64_t fromLittleEndian (uint64_t value);

  static int16_t toNetwork(int16_t value);
  static uint16_t toNetwork (uint16_t value);
  static int32_t toNetwork(int32_t value);
  static uint32_t toNetwork (uint32_t value);
  static int64_t toNetwork(int64_t value);
  static uint64_t toNetwork (uint64_t value);

  static int16_t fromNetwork(int16_t value);
  static uint16_t fromNetwork (uint16_t value);
  static int32_t fromNetwork(int32_t value);
  static uint32_t fromNetwork (uint32_t value);
  static int64_t fromNetwork(int64_t value);
  static uint64_t fromNetwork (uint64_t value);
};


inline uint16_t ByteOrder::flipBytes(uint16_t value)
{
	return ((value >> 8) & 0x00FF) | ((value << 8) & 0xFF00);
}


inline int16_t ByteOrder::flipBytes(int16_t value)
{
  return int16_t(flipBytes(uint16_t(value)));
}


inline uint32_t ByteOrder::flipBytes(uint32_t value)
{
	return ((value >> 24) & 0x000000FF) | ((value >> 8) & 0x0000FF00)
	     | ((value << 8) & 0x00FF0000) | ((value << 24) & 0xFF000000);
}


inline int32_t ByteOrder::flipBytes(int32_t value)
{
  return int32_t(flipBytes(uint32_t(value)));
}


inline uint64_t ByteOrder::flipBytes(uint64_t value)
{
  uint32_t hi = uint32_t(value >> 32);
  uint32_t lo = uint32_t(value & 0xFFFFFFFF);
  return uint64_t(flipBytes(hi)) | (uint64_t(flipBytes(lo)) << 32);
}


inline int64_t ByteOrder::flipBytes(int64_t value)
{
  return int64_t(flipBytes(uint64_t(value)));
}


//
// some macro trickery to automate the method implementation
//
#define IMPLEMENT_BYTEORDER_NOOP_(op, type) \
	inline type ByteOrder::op(type value)		\
	{											\
		return value;							\
	}
#define IMPLEMENT_BYTEORDER_FLIP_(op, type) \
	inline type ByteOrder::op(type value)		\
	{											\
		return flipBytes(value);				\
	}


  #define IMPLEMENT_BYTEORDER_NOOP(op) \
    IMPLEMENT_BYTEORDER_NOOP_(op, int16_t)	\
    IMPLEMENT_BYTEORDER_NOOP_(op, uint16_t)	\
    IMPLEMENT_BYTEORDER_NOOP_(op, int32_t)	\
    IMPLEMENT_BYTEORDER_NOOP_(op, uint32_t)	\
    IMPLEMENT_BYTEORDER_NOOP_(op, int64_t)	\
    IMPLEMENT_BYTEORDER_NOOP_(op, uint64_t)
  #define IMPLEMENT_BYTEORDER_FLIP(op) \
    IMPLEMENT_BYTEORDER_FLIP_(op, int16_t)	\
    IMPLEMENT_BYTEORDER_FLIP_(op, uint16_t)	\
    IMPLEMENT_BYTEORDER_FLIP_(op, int32_t)	\
    IMPLEMENT_BYTEORDER_FLIP_(op, uint32_t)	\
    IMPLEMENT_BYTEORDER_FLIP_(op, int64_t)	\
    IMPLEMENT_BYTEORDER_FLIP_(op, uint64_t)


#if defined(ARCH_BIG_ENDIAN)
  #define IMPLEMENT_BYTEORDER_BIG IMPLEMENT_BYTEORDER_NOOP
  #define IMPLEMENT_BYTEORDER_LIT IMPLEMENT_BYTEORDER_FLIP
#else
  #define IMPLEMENT_BYTEORDER_BIG IMPLEMENT_BYTEORDER_FLIP
  #define IMPLEMENT_BYTEORDER_LIT IMPLEMENT_BYTEORDER_NOOP
#endif


IMPLEMENT_BYTEORDER_BIG(toBigEndian)
IMPLEMENT_BYTEORDER_BIG(fromBigEndian)
IMPLEMENT_BYTEORDER_BIG(toNetwork)
IMPLEMENT_BYTEORDER_BIG(fromNetwork)
IMPLEMENT_BYTEORDER_LIT(toLittleEndian)
IMPLEMENT_BYTEORDER_LIT(fromLittleEndian)


} // namespace qsense


#endif // QSENSE_BYTEORDER_H
